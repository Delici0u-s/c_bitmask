#ifndef CONTAINERS_HASH_MAP_H_
#define CONTAINERS_HASH_MAP_H_

#include <assert.h>
#include <immintrin.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "mem.h"

/*
TODO:
cache
*/

#ifndef OA_LUT_OPTIONS
#ifdef OA_LUT_OPTIONS
/* last used items buffer in cache for fast access */
#define OA_LUT_USE_LRU_CACHE_SIZE "size"
#endif
#endif

#define OA_LUT_INTERNAL static
#define OA_LUT_API      static inline

#if defined(_WIN64) && !defined(__MINGW64__)
#pragma warning(push)
#pragma warning(disable : 4100) /* suppress unused parameter warning */
#define OA_LUT_UNUSED
#else
#define OA_LUT_UNUSED __attribute__((unused))
#endif

static_assert(sizeof(u0 *) == 8, "compile in 64 bit mode!");

typedef enum {
  OA_LUT_BUCKET_NEW = 0,
  OA_LUT_BUCKET_USED,
  OA_LUT_BUCKET_DELETED,
} oa_lut__bucket_flags;

typedef u32 (*OA_LUT_CMP_FUNC)(
  const u8 *const _a0,
  const u8 *const _a1,
  usize           _len
);
typedef u32 (*OA_LUT_HASH_FUNC)(const u0 *const _data);
typedef u0 *(*OA_LUT_ALLOC_FUNC)(usize _size, usize _align);
typedef u0  (*OA_LUT_DEALLOC_FUNC)(u0 *_data);

typedef struct oa_lut {
  usize ksize;
  usize vsize;

  struct oa_lut__key_type *soa_keys;
  struct oa_lut__val_type *soa_vals;
  u32                     *soa_full_hashes;
  u32                     *soa_bucket_states;

  OA_LUT_ALLOC_FUNC   alloc_func;
  OA_LUT_DEALLOC_FUNC dealloc_func;
  OA_LUT_CMP_FUNC     key_cmp_func;
  OA_LUT_HASH_FUNC    hash_func;

  u32 cap;
  u32 free_cnt;

  u32 (*probe_function)(
    struct oa_lut       *_lut,
    const unsigned char *_key,
    bool                 _for_insertion
  );

  u0 (*set_key)(
    OA_LUT_UNUSED const struct oa_lut *const _lut,
    struct oa_lut__key_type *const           _dst,
    const u0 *const                          _src
  );
  u8 *(*get_key)(struct oa_lut__key_type *const _key);
  u0  (*alloc_key)(
    OA_LUT_UNUSED const struct oa_lut *const     _lut,
    OA_LUT_UNUSED struct oa_lut__key_type *const _key
  );
  u0 (*dealloc_key)(
    OA_LUT_UNUSED const struct oa_lut *const     _lut,
    OA_LUT_UNUSED struct oa_lut__key_type *const _key
  );

  u0 (*set_val)(
    OA_LUT_UNUSED const struct oa_lut *const _lut,
    struct oa_lut__val_type *const           _dst,
    const u0 *const                          _src
  );
  u8 *(*get_val)(struct oa_lut__key_type *const _val);
  u0  (*alloc_val)(
    OA_LUT_UNUSED const struct oa_lut *const     _lut,
    OA_LUT_UNUSED struct oa_lut__val_type *const _val
  );
  u0 (*dealloc_val)(
    OA_LUT_UNUSED const struct oa_lut *const     _lut,
    OA_LUT_UNUSED struct oa_lut__val_type *const _val
  );

} oa_lut;

typedef struct {
  u0 *data[8ull];
} oa_lut_pointer_batch;

// clang-format off

/*
creates an open addressing lookup table
 _init_size hint to the implementation -> might oversize
 if the function pointers for alloc, dealloc, key_cmp, hash are 
	NULL: sane defaults are used
*/
OA_LUT_API oa_lut 
oa_lut_create(
  usize               _init_size,
  usize               _key_size,
  usize               _value_size, 
  OA_LUT_CMP_FUNC     _cmp_func, 
  OA_LUT_HASH_FUNC    _hash_func, 
  OA_LUT_ALLOC_FUNC   _alloc_func, 
  OA_LUT_DEALLOC_FUNC _dealloc_func
);

/*
creates an open addressing lookup table
 _init_size hint to the implementation -> might oversize
 uses sane defaults for hashing, key cmp and allocation
*/
OA_LUT_API oa_lut
oa_lut_create_simple(
  usize _init_size, 
  usize _key_size, 
  usize _value_size
);  

/*
destroys a valid, initialized oa_lut
UB when passed oa_lut is not initialized
*/
OA_LUT_API u0 
oa_lut_destroy(
  oa_lut *const _lut
);

/*
increases the visible capacity of the oa_lut,
nothing happens if new_size < current_size

!!!WARNING!!!: MAY INVALIDATE POINTERS  
*/
OA_LUT_API u0 
oa_lut_reserve(
  oa_lut *const_lut, 
  const usize new_size
);

/*
shrinks the oa_lut's capacity until the load factor is <= 0.6 or the size hits6 elements

!!!WARNING!!!: MAY INVALIDATE POINTERS  
*/
OA_LUT_API u0  
oa_lut_shrink_to_fit(
  oa_lut *const _lut
);

/*
inserts the value for a given key. 
returns 0 on success.

!!!WARNING!!!: MAY INVALIDATE POINTERS  
*/
OA_LUT_API u32
oa_lut_insert(
  oa_lut *const t, 
  const u0 *const key, 
  const u0 *const value
);

/*
returns the value pointer for a given key. 
NULL if key is not present 
*/
OA_LUT_API u0*
oa_lut_get(
  oa_lut *const _lut, 
  const u0 *const _key
);

/*
removes a key from oa_lut. 
if the key was not present or already deleted returns non-null 
else 0
*/
OA_LUT_API u32 
oa_lut_remove(
  oa_lut *const t, 
  const u0 *const key
);

/*
inserts up to 8 values for up to 8 keys. 
pass msk to indicate which keys are provided
  -> 0b11100000 for three inserts.

!!!WARNING!!!: MAY INVALIDATE POINTERS  
*/
OA_LUT_API __m256i 
oa_lut_insert8(
  oa_lut *const t, 
  const u0 *const keys[static 8ull], 
  const u0 *const values[static 8ull], 
  u8 msk
);

/*
retrieves up to 8 value pointers based on the given keys. 
pass msk to indicate which keys are provided
  -> 0b11100000 for three lookups.
*/
OA_LUT_API oa_lut_pointer_batch
oa_lut_get8(
  oa_lut *const t, 
  const u0 *const keys[static 8ull], 
  u8 msk
);

/*
removes up to 8 keys. 
pass msk to indicate which keys are provided
  -> 0b11100000 for three keys.
*/
OA_LUT_API __m256i
oa_lut_remove8(
  oa_lut *const t, 
  const u0 *const keys[static 8ull], 
  u8 msk
);
// clang-format on

#endif // CONTAINERS_HASH_MAP_H_

#if !defined(OA_LUT_IMPLEMENTATION) || 1
#define OA_LUT_IMPLEMENTATION
// #if defined(OA_LUT_IMPLEMENTATION) || 1

#define _memcpy OA_memcpy
#define _memcmp OA_memcmp

#define OA_LUT_DEFAULT_ALIGNMENT (16ull)

OA_LUT_INTERNAL u64 oa_lut__l64u(const void *_p, usize len) {
  const u8 *p  = (const u8 *)_p;
  u64       v  = 0;
  u32       t1 = 0, t2 = 0, t3 = 0;

  if (len == 0) return 0;
  if (len > 8) __builtin_unreachable();

  switch (len) {
  case 1ull: {
    __asm__ volatile("movzbl (%[p]), %[t1]"
                     : [t1] "=r"(t1)
                     : [p] "r"(p)
                     : "memory");
    v = (u64)t1;
    return v;
  }
  case 2ull: {
    __asm__ volatile("movzwl (%[p]), %[t1]"
                     : [t1] "=r"(t1)
                     : [p] "r"(p)
                     : "memory");
    v = (u64)t1;
    return v;
  }
  case 3ull: {
    __asm__ volatile("movzwl (%[p]), %[t1]\n\t"
                     "movzbl 2(%[p]), %[t2]\n\t"
                     "shll $16, %[t2]\n\t"
                     "orl %[t2], %[t1]"
                     : [t1] "=&r"(t1), [t2] "=&r"(t2)
                     : [p] "r"(p)
                     : "cc", "memory");
    v = (u64)t1;
    return v;
  }
  case 4ull: {
    __asm__ volatile("movl (%[p]), %[t1]"
                     : [t1] "=r"(t1)
                     : [p] "r"(p)
                     : "memory");
    v = (u64)t1;
    return v;
  }
  case 5ull: {
    __asm__ volatile("movl (%[p]), %[t1]\n\t"
                     "movzbl 4(%[p]), %[t2]"
                     : [t1] "=&r"(t1), [t2] "=&r"(t2)
                     : [p] "r"(p)
                     : "memory");
    v = (u64)t1 | ((u64)t2 << 32);
    return v;
  }
  case 6ull: {
    __asm__ volatile("movl (%[p]), %[t1]\n\t"
                     "movzwl 4(%[p]), %[t2]"
                     : [t1] "=&r"(t1), [t2] "=&r"(t2)
                     : [p] "r"(p)
                     : "memory");
    v = (u64)t1 | ((u64)t2 << 32);
    return v;
  }
  case 7ull: {
    __asm__ volatile("movl (%[p]), %[t1]\n\t"
                     "movzwl 4(%[p]), %[t2]\n\t"
                     "movzbl 6(%[p]), %[t3]"
                     : [t1] "=&r"(t1), [t2] "=&r"(t2), [t3] "=&r"(t3)
                     : [p] "r"(p)
                     : "memory");
    v = (u64)t1 | ((u64)t2 << 32) | ((u64)t3 << 48);
    return v;
  }
  case 8ull: {
    __asm__ volatile("movq (%[p]), %[v]" : [v] "=r"(v) : [p] "r"(p) : "memory");
    return v;
  }
  default: __builtin_unreachable();
  }
}

OA_LUT_INTERNAL u32 oa_lut__npow2(u32 x) {
  if (x == 0) {
    return 1;
  }
  x--;
  x |= x >> 1;
  x |= x >> 2;
  x |= x >> 4;
  x |= x >> 8;
  x |= x >> 16;
  x++;
  return x;
}

OA_LUT_INTERNAL u0 *oa_lut__aligned_malloc(usize size, usize align) {
#if defined(_WIN64)
  void *p = _aligned_malloc(size, align);
#else
  void *p = aligned_alloc(align, size);
#endif
  return p;
}

OA_LUT_INTERNAL u0 oa_lut__aligned_free(u0 *_ptr) {
#ifdef _WIN64
  _aligned_free(_ptr);
#else
  free(_ptr);
#endif
}

#define OA_LUT_INVALID_INDEX ((u32) - 1)

/* hash functions */

OA_LUT_INTERNAL u32 oa_lut__no_hash(const u0 *_ptrval, usize _len) {
  /*
  since we use 32 bit hashes but our SOO can store
  64-bit values we need to do a single iteration for
  better distribution of "direct hashes"
  */
  const u64 qwrd = oa_lut__l64u(_ptrval, _len);
  return (u32)(qwrd ^ (qwrd >> 32));
}

/*
TODO: fnv-1a is fine for small sizes but for larger things its slow and bad
*/
OA_LUT_INTERNAL u32 oa_lut_fnv32_hash_size(const u0 *const _str, usize _len) {
  const static u32 fnv_offst = 2166136261u;
  const static u32 fnv_prm   = 16777619u;
  const usize      len       = _len;
  u32              hash      = fnv_offst;
  for (usize i = 0; i != len; i++) {
    hash = (((u8 *)_str)[i] ^ hash) * fnv_prm;
  }
  return hash;
}
/* \hash functions */

OA_LUT_INTERNAL u32
oa_lut__def_cmp(const u8 *const _a0, const u8 *const _a1, usize _len) {
  return _memcmp(_a0, _a1, _len);
}

typedef struct oa_lut__key_type {
  union {
    u8 *key_ptr;
    u64 key_soo_qword;
  };
} oa_lut__key_type;

typedef struct oa_lut__val_type {
  union {
    u8 *val_ptr;
    u64 val_soo_qword;
  };
} oa_lut__val_type;

/* --- KEY + SOO --- */
OA_LUT_INTERNAL u0 oa_lut__set_key_soo(
  OA_LUT_UNUSED const oa_lut *const _lut,
  oa_lut__key_type *const           _dst,
  const u0 *const                   _src
) {
  _dst->key_soo_qword = oa_lut__l64u(_src, _lut->ksize);
}

OA_LUT_INTERNAL u0 *oa_lut__get_key_soo(oa_lut__key_type *const _key) {
  return &_key->key_soo_qword;
}

OA_LUT_INTERNAL u0 oa_lut__alloc_key_soo(
  OA_LUT_UNUSED const oa_lut *const     _lut,
  OA_LUT_UNUSED oa_lut__key_type *const _key
) {}

OA_LUT_INTERNAL u0 oa_lut__dealloc_key_soo(
  OA_LUT_UNUSED const oa_lut *const     _lut,
  OA_LUT_UNUSED oa_lut__key_type *const _key
) {}

/* --- KEY + NO-SOO --- */
OA_LUT_INTERNAL u0 oa_lut__set_key_no_soo(
  const oa_lut *const     _lut,
  oa_lut__key_type *const _dst,
  const u0 *const         _src
) {
  _memcpy(_dst->key_ptr, _src, _lut->ksize);
}

OA_LUT_INTERNAL u0 *oa_lut__get_key_no_soo(oa_lut__key_type *const _key) {
  return _key->key_ptr;
}

OA_LUT_INTERNAL u0 oa_lut__alloc_key_no_soo(
  const oa_lut *const     _lut,
  oa_lut__key_type *const _key
) {
  _key->key_ptr = _lut->alloc_func(_lut->ksize, OA_LUT_DEFAULT_ALIGNMENT);
}

OA_LUT_INTERNAL u0 oa_lut__dealloc_key_no_soo(
  const oa_lut *const     _lut,
  oa_lut__key_type *const _key
) {
  _lut->dealloc_func(_key->key_ptr);
}

/* --- VAL + SOO --- */
OA_LUT_INTERNAL u0 oa_lut__set_val_soo(
  OA_LUT_UNUSED const oa_lut *const _lut,
  oa_lut__val_type *const           _dst,
  const u0 *const                   _src
) {
  _dst->val_soo_qword = oa_lut__l64u(_src, _lut->vsize);
}

OA_LUT_INTERNAL u0 *oa_lut__get_val_soo(oa_lut__key_type *const _val) {
  return &_val->key_soo_qword;
}

OA_LUT_INTERNAL u0 oa_lut__alloc_val_soo(
  OA_LUT_UNUSED const oa_lut *const     _lut,
  OA_LUT_UNUSED oa_lut__val_type *const _val
) {}

OA_LUT_INTERNAL u0 oa_lut__dealloc_val_soo(
  OA_LUT_UNUSED const oa_lut *const     _lut,
  OA_LUT_UNUSED oa_lut__val_type *const _val
) {}

/* --- VAL + NO-SOO --- */
OA_LUT_INTERNAL u0 oa_lut__set_val_no_soo(
  const oa_lut *const     _lut,
  oa_lut__val_type *const _dst,
  const u0 *const         _src
) {
  _memcpy(_dst->val_ptr, _src, _lut->vsize);
}

OA_LUT_INTERNAL u0 *oa_lut__get_val_no_soo(oa_lut__val_type *const _val) {
  return _val->val_ptr;
}

OA_LUT_INTERNAL u0 oa_lut__alloc_val_no_soo(
  const oa_lut *const     _lut,
  oa_lut__val_type *const _val
) {
  _val->val_ptr = _lut->alloc_func(_lut->vsize, OA_LUT_DEFAULT_ALIGNMENT);
}

OA_LUT_INTERNAL u0 oa_lut__dealloc_val_no_soo(
  const oa_lut *const     _lut,
  oa_lut__val_type *const _val
) {
  _lut->dealloc_func(_val->val_ptr);
}

/* probe functions */
OA_LUT_INTERNAL u32 oa_lut__probe_no_soo(
  oa_lut *const   _lut,
  const u8 *const _key,
  const bool      _for_insertion
) {}
OA_LUT_INTERNAL u32 oa_lut__probe_key_soo(
  oa_lut *const              _lut,
  const unsigned char *const _key,
  const bool                 _for_insertion
) {}
OA_LUT_INTERNAL u32 oa_lut__probe_val_soo(
  oa_lut *const              _lut,
  const unsigned char *const _key,
  const bool                 _for_insertion
) {}
OA_LUT_INTERNAL u32 oa_lut__probe_all_soo(
  oa_lut *const              _lut,
  const unsigned char *const _key,
  const bool                 _for_insertion
) {}

/* api implementations */
OA_LUT_API oa_lut oa_lut_create_verbose(
  usize                 _init_size,
  usize                 _key_size,
  usize                 _value_size,
  OA_LUT_CMP_FUNC     _cmp_func,
  OA_LUT_HASH_FUNC    _hash_func,
  OA_LUT_ALLOC_FUNC   _alloc_func,
  OA_LUT_DEALLOC_FUNC _dealloc_func
) {
  /*
  @Delici0u-s: you argued that we should just call oa_lut_create_verbose with
  defaults in oa_lut_create_simple however what if the user only wants to
  provide functions pertially: e.g a custom cmp and hash but no custom
  allocator. in this case we could implement the actual defaults handling in
  this function and just make _simple call _verbose with those parameters as
  NULL. but is the existance of _simple even justified at that point?
  */

  /*
  start with oversized map
  */
  _init_size = oa_lut__npow2(_init_size * 2u);

  assert(_key_size);
  assert(_value_size);

  /*
  make logic of the entire hashmap simpler and prevent people from writing
  stupid fucking code.
  */
  if (_key_size <= 8u) {
    assert(
      !_cmp_func ||
      "User may only provide custom compare function for non SOO keys"
    );
    assert(
      !_hash_func ||
      "User may only provide custom hash function for non SOO keys"
    );
    _alloc_func &&printf(
      "[oa_lut] (warn) : custom allocator for OA_LUT will not be used for keys "
      "and values!"
    );
  } else {
    if (!_cmp_func) {
      _cmp_func = oa_lut__def_cmp;
    }
    if (!_alloc_func) {
      _alloc_func = oa_lut__aligned_malloc;
    }
    if (!_dealloc_func) {
      _dealloc_func = oa_lut__aligned_free;
    }
  }

  assert(
    (_alloc_func && _dealloc_func || !_alloc_func && !_dealloc_func) ||
    "User must provide both allocation and deallocation funtion or none!"
  );

  oa_lut out = {0};

  out.cap      = _init_size;
  out.free_cnt = _init_size;

  out.alloc_func   = _alloc_func;
  out.dealloc_func = _dealloc_func;
  out.key_cmp_func = _cmp_func;

  if (_key_size <= 8u) {

    out.set_key = oa_lut__set_key_soo;
  }

  return out;
}

OA_LUT_API oa_lut
oa_lut_create_simple(u32 _init_size, u32 _key_size, u32 _value_size) {}
OA_LUT_API u0   oa_lut_destroy(oa_lut *const _lut) {}
OA_LUT_API u0   oa_lut_upsize(oa_lut *const _lut) {}
OA_LUT_API u0   oa_lut_reserve(oa_lut *const_lut, const usize new_size) {}
OA_LUT_API u0   oa_lut_shrink_to_fit(oa_lut *const _lut) {}
OA_LUT_API bool oa_lut_remove(oa_lut *const _lut, const void *const _key) {}
OA_LUT_API u0   oa_lut_insert(
    oa_lut *const     _lut,
    const void *const _key,
    const void *const _value
  ) {}
OA_LUT_API u0 *oa_lut_get(oa_lut *const _lut, const void *const _key) {}

#if defined(_WIN64) && !defined(__MINGW64__)
#pragma warning(pop)
#endif
#endif
